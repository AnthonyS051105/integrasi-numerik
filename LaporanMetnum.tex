\documentclass[a4paper, 12pt]{article}

%------------------------------------------------%
% PENGATURAN PAKET DAN DOKUMEN
%------------------------------------------------%
\usepackage[utf8]{inputenc}
\usepackage[bahasa]{babel}      % Mengatur bahasa Indonesia
\usepackage{graphicx}           % Untuk memasukkan gambar (logo)
\usepackage{amsmath}            % Untuk simbol dan lingkungan matematika
\usepackage{geometry}           % Untuk mengatur margin halaman
\usepackage{times}              % Menggunakan font Times New Roman
\usepackage{listings}           % Untuk menampilkan kode
\usepackage{xcolor}             % Untuk pewarnaan syntax
\usepackage{tabularx}
\usepackage{float}


% Pengaturan listings untuk Python
\lstset{
    language=Python,
    basicstyle=\ttfamily\small,
    keywordstyle=\color{blue}\bfseries,
    stringstyle=\color{red},
    commentstyle=\color{green!60!black}\itshape,
    numberstyle=\tiny\color{gray},
    numbers=left,
    stepnumber=1,
    numbersep=5pt,
    backgroundcolor=\color{gray!10},
    frame=single,
    breaklines=true,
    breakatwhitespace=true,
    tabsize=4,
    showstringspaces=false
}

% Pengaturan margin halaman
\geometry{
    a4paper,
    left=25mm,
    right=25mm,
    top=25mm,
    bottom=25mm,
}

% Pengaturan jarak antar paragraf (non-indented)
\usepackage{parskip}
\setlength{\parindent}{0pt}
\setlength{\parskip}{1.5ex}

% Menonaktifkan nomor halaman untuk halaman pertama
\thispagestyle{empty}

%------------------------------------------------%
% AWAL DOKUMEN
%------------------------------------------------%
\begin{document}

%------------------------------------------------%
% BAGIAN JUDUL (COVER)
%------------------------------------------------%
\begin{center}
    % Logo UGM
    \includegraphics[width=3cm]{HitamPutih.jpg} % Pastikan file logo ada di folder yang sama

    \vspace{0.1cm} % Memberi jarak vertikal

    % Informasi Universitas
    \textbf{UNIVERSITAS GADJAH MADA} \\
    \textbf{FAKULTAS TEKNIK} \\
    \textbf{DEPARTEMEN TEKNIK ELEKTRO DAN TEKNOLOGI INFORMASI}

    \vspace{0.1cm}

    % Garis horizontal pemisah
    \rule{\textwidth}{1.2pt}

    \vspace{0.2cm}

    % Judul dan Subjudul
    \textbf{TUGAS METODE NUMERIS} \\
    \vspace{0.1cm}
    \textbf{\Large INTEGRASI NUMERIK DENGAN METODE \\ TRAPEZOIDAL, RICHARDSON, ROMBERG, ADAPTIVE, \\ DAN GAUSSIAN QUADRATURE} \\

    \vspace{0.25cm}

    % Informasi Penulis
    Ditulis oleh: \\
    \vspace{0.1cm}
    \textbf{\large Kelompok:} \\
    \vspace{0.1cm}
    \textbf{1. Nathanael Satya Saputra (NIM NAEL)} \\
    \textbf{2. Muhammad Nafal Zakin Rustanto (24/535255/TK/59364)} \\
    \textbf{3. Yohanes Anthony Saputra (NIM ANTHONY)} \\
    \textbf{4. Johannes De Deo Dimas Aryobimo (24/540351/TK/59948)}
\end{center}

\vspace{0.5cm} % Jarak pemisah sebelum masuk ke konten laporan

%------------------------------------------------%
% BAGIAN 1: TEORI TIAP METODE
%------------------------------------------------%
\section*{BAGIAN 1: Dasar Teori}

\subsection*{1.1. Integrasi Analitik (Metode Eksak)}

Integrasi analitik adalah metode perhitungan integral menggunakan rumus-rumus kalkulus secara langsung. Metode ini memberikan nilai eksak (tepat) dari suatu integral jika fungsi yang diintegralkan memiliki antiturunan yang dapat ditentukan.

\textbf{Definisi Integral Tentu:}

Integral tentu dari fungsi $f(x)$ pada interval $[a, b]$ didefinisikan sebagai:
\[
I = \int_{a}^{b} f(x) \, dx = F(b) - F(a)
\]
di mana $F(x)$ adalah antiturunan dari $f(x)$, yaitu $F'(x) = f(x)$.

\textbf{Teorema Fundamental Kalkulus:}

Jika $f(x)$ kontinu pada interval $[a, b]$ dan $F(x)$ adalah antiturunan dari $f(x)$, maka:
\[
\int_{a}^{b} f(x) \, dx = F(x) \Big|_{a}^{b} = F(b) - F(a)
\]

\textbf{Kegunaan:}

Hasil dari integrasi analitik digunakan sebagai nilai pembanding (nilai eksak) untuk mengevaluasi akurasi metode-metode integrasi numerik. Error dari metode numerik dihitung sebagai selisih absolut antara hasil numerik dengan nilai eksak ini.

\textbf{Algoritma:}

\begin{verbatim}
1. Tentukan fungsi f(x) dan batas integrasi [a, b]
2. Cari antiturunan F(x) dari f(x)
3. Hitung F(b) - F(a)
4. Hasil adalah nilai eksak integral
\end{verbatim}

\textbf{Implementasi Python:}

\begin{lstlisting}
import numpy as np

# Contoh untuk f(x) = cos(x) pada [0, pi/2]
a = 0
b = np.pi / 2
# Antiturunan cos(x) adalah sin(x)
exact = np.sin(b) - np.sin(a)  # = 1.0

# Contoh untuk f(x) = x^2 pada [0, 1]
a = 0
b = 1
# Antiturunan x^2 adalah x^3/3
exact = (b**3 / 3) - (a**3 / 3)  # = 1/3
\end{lstlisting}

\subsection*{1.2. Metode Trapezoidal Rule}

Metode \textit{Trapezoidal Rule} merupakan salah satu metode numerik untuk menghitung pendekatan integral tentu dari suatu fungsi yang sulit atau tidak dapat diintegralkan secara analitik. Ide dari metode ini adalah dengan membagi daerah di bawah kurva fungsi $f(x)$ pada interval $[a,b]$ menjadi sejumlah bagian kecil yang berbentuk trapesium, kemudian menjumlahkan luas seluruh trapesium tersebut untuk memperoleh nilai pendekatan dari integral.

Secara matematis, integral tentu dari $f(x)$ pada interval $[a,b]$ dapat ditulis sebagai:
\[
\int_a^b f(x) \, dx
\]

Jika interval $[a,b]$ dibagi menjadi $n$ subinterval yang sama panjang dengan lebar $h = \frac{b-a}{n}$, maka dengan pendekatan \textit{Trapezoidal Rule} nilai integral yakni
\[
\int_a^b f(x) \, dx \approx \frac{h}{2} \left[ f(x_0) + 2\sum_{i=1}^{n-1} f(x_i) + f(x_n) \right]
\]
dengan $x_0 = a$, $x_n = b$, dan $x_i = a + i \cdot h$ untuk $i = 1, 2, \ldots, n-1$.

\textbf{Algoritma:}

\begin{verbatim}
Input: fungsi f(x), batas a dan b, jumlah subinterval n
1. Hitung h = (b - a) / n
2. Buat array x dengan n+1 titik: x[i] = a + i*h
3. Hitung nilai fungsi y[i] = f(x[i]) untuk semua i
4. result = h * (0.5*y[0] + sum(y[1] sampai y[n-1]) + 0.5*y[n])
Output: result
\end{verbatim}

\textbf{Implementasi Python:}

\begin{lstlisting}
import numpy as np

def trapezoidal_rule(f, a, b, n):
    """
    Metode Trapezoidal Rule
    f: fungsi yang akan diintegralkan
    a: batas bawah
    b: batas atas
    n: jumlah subinterval
    """
    h = (b - a) / n
    x = np.linspace(a, b, n + 1)
    y = f(x)
    
    result = h * (0.5 * y[0] + np.sum(y[1:-1]) + 0.5 * y[-1])
    return result

# Contoh penggunaan
def f(x):
    return np.cos(x)

result = trapezoidal_rule(f, 0, np.pi/2, 4)
\end{lstlisting}

\subsection*{1.3. Metode Richardson Extrapolation}

\textbf{Richardson Extrapolation} adalah teknik numerik untuk meningkatkan akurasi hasil pendekatan dengan mengkombinasikan beberapa hasil pendekatan yang memiliki ukuran langkah berbeda. Metode ini sangat efektif untuk mempercepat konvergensi hasil numerik.

\textbf{Prinsip Dasar:}

Misalkan $N(h)$ adalah pendekatan numerik dari nilai eksak $N$ dengan ukuran langkah $h$. Jika error dapat dinyatakan sebagai deret pangkat dari $h$:
\[
N(h) = N + a_1 h^p + a_2 h^{2p} + a_3 h^{3p} + \cdots
\]

Maka dengan menggunakan dua pendekatan dengan ukuran langkah berbeda ($h$ dan $\frac{h}{2}$), kita dapat mengeliminasi suku error orde terendah.

\textbf{Rumus Richardson Extrapolation:}

Untuk integrasi numerik menggunakan Trapezoidal Rule, formula Richardson Extrapolation diberikan oleh:
\[
R_{i,j} = R_{i,j-1} + \frac{R_{i,j-1} - R_{i-1,j-1}}{4^j - 1}
\]

di mana:
\begin{itemize}
    \item $R_{i,0}$ adalah hasil Trapezoidal Rule dengan $n = 2^i$ subinterval
    \item $R_{i,j}$ adalah hasil ekstrapolasi pada level $i$ dan kolom $j$
    \item Setiap kolom $j$ mengeliminasi error orde $O(h^{2j+2})$
\end{itemize}

\textbf{Tabel Richardson:}

Tabel Richardson memiliki struktur:
\begin{center}
\begin{tabular}{c|cccc}
$i$ & $j=0$ & $j=1$ & $j=2$ & $j=3$ \\ \hline
0 & $R_{0,0}$ & & & \\
1 & $R_{1,0}$ & $R_{1,1}$ & & \\
2 & $R_{2,0}$ & $R_{2,1}$ & $R_{2,2}$ & \\
3 & $R_{3,0}$ & $R_{3,1}$ & $R_{3,2}$ & $R_{3,3}$ \\
\end{tabular}
\end{center}

Nilai pada diagonal utama ($R_{0,0}, R_{1,1}, R_{2,2}, \ldots$) menunjukkan peningkatan akurasi yang signifikan.

\textbf{Algoritma:}

\begin{verbatim}
Input: fungsi f(x), batas a dan b, max_level
1. Inisialisasi matriks R berukuran max_level x max_level
2. Untuk i = 0 sampai max_level-1:
   a. n = 2^i
   b. R[i][0] = trapezoidal_rule(f, a, b, n)
3. Untuk j = 1 sampai max_level-1:
   a. Untuk i = j sampai max_level-1:
      R[i][j] = R[i][j-1] + (R[i][j-1] - R[i-1][j-1])/(4^j - 1)
4. Hasil terbaik adalah R[max_level-1][max_level-1]
Output: matriks R
\end{verbatim}

\textbf{Implementasi Python:}

\begin{lstlisting}
import numpy as np

def richardson_extrapolation(f, a, b, max_level=5):
    """
    Metode Richardson Extrapolation
    Menggunakan trapezoidal rule sebagai basis dan melakukan 
    ekstrapolasi
    """
    R = np.zeros((max_level, max_level))
    
    # Kolom pertama: hasil trapezoidal rule dengan n = 2^i
    for i in range(max_level):
        n = 2**i
        R[i][0] = trapezoidal_rule(f, a, b, n)
    
    # Richardson extrapolation untuk kolom-kolom berikutnya
    for j in range(1, max_level):
        for i in range(j, max_level):
            R[i][j] = R[i][j-1] + (R[i][j-1] - R[i-1][j-1]) / (4**j - 1)
    
    return R

# Contoh penggunaan
richardson = richardson_extrapolation(f, 0, np.pi/2, max_level=5)
result = richardson[4][4]  # Hasil terbaik
\end{lstlisting}

\subsection*{1.4. Metode Romberg Integration}

\textbf{Romberg Integration} adalah metode integrasi numerik yang menggabungkan Trapezoidal Rule dengan Richardson Extrapolation. Perbedaan utama dengan Richardson standar adalah cara menghitung kolom pertama menggunakan teknik rekursif yang lebih efisien.

\textbf{Rumus Romberg:}

Kolom pertama dihitung dengan:
\[
R_{0,0} = \frac{b-a}{2}[f(a) + f(b)]
\]
\[
R_{i,0} = \frac{1}{2}R_{i-1,0} + h_i \sum_{k=1}^{2^{i-1}} f(a + (2k-1)h_i)
\]
di mana $h_i = \frac{b-a}{2^i}$.

Untuk kolom berikutnya, menggunakan Richardson Extrapolation:
\[
R_{i,j} = R_{i,j-1} + \frac{R_{i,j-1} - R_{i-1,j-1}}{4^j - 1}
\]

\textbf{Algoritma:}

\begin{verbatim}
Input: fungsi f(x), batas a dan b, max_level
1. Inisialisasi matriks R berukuran max_level x max_level
2. R[0][0] = 0.5 * (b - a) * (f(a) + f(b))
3. Untuk i = 1 sampai max_level-1:
   a. h = (b - a) / 2^i
   b. sum_val = 0
   c. Untuk k = 1 sampai 2^(i-1):
      sum_val += f(a + (2*k - 1) * h)
   d. R[i][0] = 0.5 * R[i-1][0] + h * sum_val
4. Untuk i = 1 sampai max_level-1:
   a. Untuk j = 1 sampai i:
      R[i][j] = R[i][j-1] + (R[i][j-1] - R[i-1][j-1])/(4^j - 1)
Output: matriks R
\end{verbatim}

\textbf{Implementasi Python:}

\begin{lstlisting}
import numpy as np

def romberg_integration(f, a, b, max_level=5):
    """
    Metode Romberg Integration
    Menghasilkan tabel Romberg R[i][j]
    """
    R = np.zeros((max_level, max_level))
    
    # R[0][0] menggunakan trapezoidal rule dengan 1 interval
    R[0][0] = 0.5 * (b - a) * (f(a) + f(b))
    
    for i in range(1, max_level):
        h = (b - a) / (2**i)
        
        # Hitung sum untuk titik-titik baru
        sum_val = 0
        for k in range(1, 2**(i-1) + 1):
            sum_val += f(a + (2*k - 1) * h)
        
        R[i][0] = 0.5 * R[i-1][0] + h * sum_val
        
        # Richardson extrapolation
        for j in range(1, i + 1):
            R[i][j] = R[i][j-1] + (R[i][j-1] - R[i-1][j-1]) / (4**j - 1)
    
    return R

# Contoh penggunaan
romberg = romberg_integration(f, 0, np.pi/2, max_level=5)
result = romberg[4][4]  # Hasil terbaik
\end{lstlisting}

\subsection*{1.5. Metode Adaptive Integration}

\textbf{Adaptive Integration} adalah metode integrasi numerik yang secara otomatis menyesuaikan ukuran interval berdasarkan perilaku fungsi. Metode ini menggunakan Simpson's Rule sebagai basis dan membagi interval menjadi subinterval yang lebih kecil jika diperlukan untuk mencapai toleransi error yang ditentukan.

\textbf{Simpson's Rule:}

Untuk interval $[a, b]$:
\[
S = \frac{h}{6}[f(a) + 4f(c) + f(b)]
\]
di mana $c = \frac{a+b}{2}$ dan $h = b - a$.

\textbf{Kriteria Adaptif:}

Interval dibagi dua jika:
\[
|S_2 - S| > 15 \times \text{tol}
\]
di mana $S$ adalah hasil Simpson untuk keseluruhan interval dan $S_2 = S_{\text{left}} + S_{\text{right}}$ adalah hasil dari dua subinterval.

\textbf{Algoritma:}

\begin{verbatim}
Input: fungsi f(x), batas a dan b, toleransi tol, max_depth
1. Fungsi simpson_rule(a, b):
   c = (a + b) / 2
   h = b - a
   return (h/6) * (f(a) + 4*f(c) + f(b))
   
2. Fungsi adaptive_aux(a, b, tol, S, fa, fb, fc, depth):
   a. Hitung titik tengah: d = (a+c)/2, e = (c+b)/2
   b. Hitung nilai fungsi: fd = f(d), fe = f(e)
   c. Sleft = (c-a)/6 * (fa + 4*fd + fc)
   d. Sright = (b-c)/6 * (fc + 4*fe + fb)
   e. S2 = Sleft + Sright
   f. Jika depth <= 0 atau |S2 - S| <= 15*tol:
      return S2 + (S2 - S)/15
   g. Jika tidak:
      return adaptive_aux(a, c, ...) + adaptive_aux(c, b, ...)
      
3. c = (a + b) / 2
4. Hitung S = simpson_rule(a, b)
5. return adaptive_aux(a, b, tol, S, f(a), f(b), f(c), max_depth)
Output: hasil integral
\end{verbatim}

\textbf{Implementasi Python:}

\begin{lstlisting}
import numpy as np

def adaptive_simpson(f, a, b, tol=1e-10, max_depth=50):
    """
    Metode Adaptive Integration menggunakan Simpson's Rule
    """
    def simpson_rule(f, a, b):
        """Simpson's rule untuk interval [a, b]"""
        c = (a + b) / 2
        h = b - a
        return (h / 6) * (f(a) + 4 * f(c) + f(b))
    
    def adaptive_aux(f, a, b, tol, S, fa, fb, fc, depth):
        """Fungsi rekursif untuk adaptive integration"""
        c = (a + b) / 2
        d = (a + c) / 2
        e = (c + b) / 2
        
        fd = f(d)
        fe = f(e)
        
        Sleft = (c - a) / 6 * (fa + 4 * fd + fc)
        Sright = (b - c) / 6 * (fc + 4 * fe + fb)
        S2 = Sleft + Sright
        
        if depth <= 0 or abs(S2 - S) <= 15 * tol:
            return S2 + (S2 - S) / 15
        
        return (adaptive_aux(f, a, c, tol/2, Sleft, fa, fc, fd, depth-1) +
                adaptive_aux(f, c, b, tol/2, Sright, fc, fb, fe, depth-1))
    
    c = (a + b) / 2
    fa = f(a)
    fb = f(b)
    fc = f(c)
    S = simpson_rule(f, a, b)
    
    return adaptive_aux(f, a, b, tol, S, fa, fb, fc, max_depth)

# Contoh penggunaan
result = adaptive_simpson(f, 0, np.pi/2)
\end{lstlisting}

\subsection*{1.6. Metode Gaussian Quadrature}

\textbf{Gaussian Quadrature} adalah metode integrasi numerik yang menggunakan titik-titik sampling optimal (nodes) dan bobot (weights) yang telah ditentukan secara matematis untuk memberikan akurasi maksimal dengan jumlah evaluasi fungsi minimal.

\textbf{Rumus Umum:}

Untuk interval $[-1, 1]$:
\[
\int_{-1}^{1} f(x) \, dx \approx \sum_{i=1}^{n} w_i f(x_i)
\]
di mana $x_i$ adalah nodes (Gauss-Legendre) dan $w_i$ adalah weights.

\textbf{Transformasi ke Interval $[a, b]$:}

Untuk interval $[a, b]$, gunakan transformasi:
\[
x = \frac{1}{2}[(b-a)t + (a+b)]
\]
sehingga:
\[
\int_{a}^{b} f(x) \, dx = \frac{b-a}{2} \int_{-1}^{1} f\left(\frac{1}{2}[(b-a)t + (a+b)]\right) dt
\]
\[
\approx \frac{b-a}{2} \sum_{i=1}^{n} w_i f\left(\frac{1}{2}[(b-a)x_i + (a+b)]\right)
\]

\textbf{Nodes dan Weights untuk 5-point Gauss-Legendre:}

\begin{center}
\begin{tabular}{c|c}
$x_i$ (nodes) & $w_i$ (weights) \\ \hline
$-0.9061798459$ & $0.2369268851$ \\
$-0.5384693101$ & $0.4786286705$ \\
$0.0$ & $0.5688888889$ \\
$0.5384693101$ & $0.4786286705$ \\
$0.9061798459$ & $0.2369268851$ \\
\end{tabular}
\end{center}

\textbf{Algoritma:}

\begin{verbatim}
Input: fungsi f(x), batas a dan b, jumlah titik n
1. Tentukan nodes dan weights untuk n-point:
   - Jika n=5, gunakan tabel di atas
   - Jika tidak, hitung dari polinomial Legendre
2. result = 0
3. Untuk i = 1 sampai n:
   a. x = 0.5 * ((b - a) * nodes[i] + (a + b))
   b. result += weights[i] * f(x)
4. result *= 0.5 * (b - a)
Output: result
\end{verbatim}

\textbf{Implementasi Python:}

\begin{lstlisting}
import numpy as np

def gaussian_quadrature(f, a, b, n=5):
    """
    Metode Gaussian Quadrature
    Menggunakan n-point Gauss-Legendre quadrature
    """
    if n == 5:
        # 5-point Gauss-Legendre nodes dan weights
        nodes = np.array([
            -0.9061798459386640,
            -0.5384693101056831,
            0.0,
            0.5384693101056831,
            0.9061798459386640
        ])
        
        weights = np.array([
            0.2369268850561891,
            0.4786286704993665,
            0.5688888888888889,
            0.4786286704993665,
            0.2369268850561891
        ])
    else:
        # Untuk n lain, gunakan numpy (opsional)
        nodes, weights = np.polynomial.legendre.leggauss(n)
    
    # Transformasi dari [-1, 1] ke [a, b]
    result = 0
    for i in range(len(nodes)):
        x = 0.5 * ((b - a) * nodes[i] + (a + b))
        result += weights[i] * f(x)
    
    result *= 0.5 * (b - a)
    return result

# Contoh penggunaan
result = gaussian_quadrature(f, 0, np.pi/2, n=5)
\end{lstlisting}

%------------------------------------------------%
% BAGIAN 2: LANGKAH PERHITUNGAN
%------------------------------------------------%
\section*{BAGIAN 2: Langkah Perhitungan pada Program}

\subsection*{2.1. Perhitungan Integrasi Analitik (Nilai Eksak)}

\textbf{Fungsi 1: } $f(x) = \cos(x)$ pada interval $[0, \frac{\pi}{2}]$

Langkah perhitungan:
\begin{align*}
I_1 &= \int_{0}^{\pi/2} \cos(x) \, dx \\
&= \sin(x) \Big|_{0}^{\pi/2} \\
&= \sin\left(\frac{\pi}{2}\right) - \sin(0) \\
&= 1 - 0 \\
&= 1
\end{align*}

\textbf{Nilai Eksak: } $I_1 = 1.0$

\vspace{0.3cm}

\textbf{Fungsi 2: } $f(x) = x^2$ pada interval $[0, 1]$

Langkah perhitungan:
\begin{align*}
I_2 &= \int_{0}^{1} x^2 \, dx \\
&= \frac{x^3}{3} \Big|_{0}^{1} \\
&= \frac{1^3}{3} - \frac{0^3}{3} \\
&= \frac{1}{3} - 0 \\
&= \frac{1}{3}
\end{align*}

\textbf{Nilai Eksak: } $I_2 = 0.333333...$ atau $\frac{1}{3}$

% TRAPEZOIDAL RULE

\subsection*{2.2. Perhitungan Metode Trapezoidal Rule}

\textbf{Fungsi 1:} $f(x) = \cos(x)$ pada interval $[0, \frac{\pi}{2}]$

\textbf{Fungsi 2:} $f(x) = x^2$ pada interval $[0, 1]$

Langkah perhitungan dengan program Python:

Pertama, impor library numpy agar mempermudah melakukan perhitungan

\begin{lstlisting}
import numpy as np
\end{lstlisting}

Kemudian, mendeklarasi fungsi untuk melakukan perhitungan metode \textit{Trapezoidal Rule}, fungsi ini menerimpa input : 
\begin{itemize}
    \item f: fungsi yang akan diintegralkan, yaitu fungsi 1 : $f(x) = \cos(x)$ dan fungsi 2 : $f(x) = x^2$
    \item a: batas bawah, yaitu $0$ untuk fungsi 1 dan fungsi 2
    \item b: batas atas, yaitu $\frac{\pi}{2}$ untuk fungsi 1 dan $1$ untuk fungsi 2
    \item n: jumlah subinterval, yaitu $n = [4,8]$
\end{itemize}

\begin{lstlisting}
def trapezoidal_rule(f, a, b, n):
\end{lstlisting}

Fungsi ini bekerja dengan tiga langkah utama: menentukan lebar trapezoid, menghasilkan grid titik evaluasi, dan mengukur tinggi fungsi di setiap titik

\begin{lstlisting}
    h = (b - a) / n
    x = np.linspace(a, b, n + 1)
    y = f(x)
\end{lstlisting}

Perhitungan akhir dilakukan dengan menerapkan rumus inti trapezoidal rule: mengalikan lebar trapezoid dengan penjumlahan nilai fungsi di semua titik, dimana nilai di ujung-ujung interval diberi bobot 0.5 dan nilai di titik-titik tengah diberi bobot penuh, kemudian hasilnya langsung dikembalikan sebagai solusi integral numerik

\begin{lstlisting}
    result = h * (0.5 * y[0] + np.sum(y[1:-1]) + 0.5 * y[-1])
    return result
\end{lstlisting}

\textbf{Hasil Akhir : }

\subsection*{Soal 1: $\int_{0}^{\frac{\pi}{2}} \cos(x)  dx$}

Integral fungsi $\cos(x)$ pada interval $[0, \frac{\pi}{2}]$ memiliki nilai eksak $1.00000000000000$. Berikut hasil aproksimasi dengan metode \textit{Trapezoidal Rule}:

\begin{itemize}
    \item \textbf{$n = 4$}: Nilai $0.987115809972776$ dengan error $1.288420 \times 10^{-2}$
    \item \textbf{$n = 8$}: Nilai $0.996785171886169$ dengan error $3.214828 \times 10^{-3}$
\end{itemize}

\subsection*{Soal 2: $\int_{0}^{1} x^2  dx$}

Integral fungsi $x^2$ pada interval $[0, 1]$ memiliki nilai eksak $0.333333333333333$. Berikut hasil aproksimasi dengan metode \textit{Trapezoidal Rule}:

\begin{itemize}
    \item \textbf{$n = 4$}: Nilai $0.343750000000000$ dengan error $1.041667 \times 10^{-2}$
    \item \textbf{$n = 8$}: Nilai $0.335937500000000$ dengan error $2.604167 \times 10^{-3}$
\end{itemize}

Terlihat bahwa dengan penambahan jumlah subinterval $n$, nilai aproksimasi semakin mendekati nilai eksak dan error semakin mengecil.

\subsection*{2.3. Perhitungan Metode Richardson Extrapolation}

[Isi langkah-langkah perhitungan menggunakan metode Richardson Extrapolation]

% ROMBERG INTEGRATION

\subsection*{2.4. Perhitungan Metode Romberg Integration}

\textbf{Fungsi 1:} $f(x) = \cos(x)$ pada interval $[0, \frac{\pi}{2}]$

\textbf{Fungsi 2:} $f(x) = x^2$ pada interval $[0, 1]$

Langkah perhitungan dengan program Python:

Impor \textit{Library} NumPy
\begin{lstlisting}
import numpy as np
\end{lstlisting}

Mendeklarasikan fungsi romberg integration dengan menerima input:

\begin{itemize}
    \item \textbf{f}: fungsi yang akan diintegralkan, fungsi 1 : $f(x) = \cos(x)$ dan fungsi 2 : $f(x) = x^2$
    \item \textbf{a}: batas bawah integral, yaitu 0 untuk fungsi 1 dan fungsi 2
    \item \textbf{b}: batas atas integral, yaitu $\frac{\pi}{2}$ untuk fungsi 1 dan $1$ untuk fungsi 2
    \item \textbf{max\_level=3}: jumlah level ekstrapolasi (opsional, default 3)
\end{itemize}

\begin{lstlisting}
def romberg_integration(f, a, b, max_level=3):
\end{lstlisting}

Kode ini membuat tabel berbentuk matriks nol dengan ukuran $max level \times max level$. Tabel ini akan menyimpan semua perhitungan integral pada berbagai tingkat akurasi. Setiap elemen $R[i,j]$ mewakili aproksimasi integral di level trapezoidal i dan level ekstrapolasi j.
\begin{lstlisting}
    R = np.zeros((max_level, max_level))
\end{lstlisting}

Metode Romberg menggunakan dua loop: pertama menghitung aproksimasi trapezoidal dengan subinterval $2^i$ yang disimpan di $R[i,0]$, lalu loop kedua melakukan ekstrapolasi Richardson dengan rumus $R[i,j] = R[i,j-1] + \frac{R[i,j-1] - R[i-1,j-1]}{4^j - 1}$ untuk meningkatkan akurasi secara eksponensial melalui eliminasi error berurutan.
\begin{lstlisting}
    R = np.zeros((max_level, max_level))
    for i in range(max_level):
        n = 2**i
        R[i, 0] = trapezoidal_rule(f, a, b, n)
    
        for j in range(1, i + 1):
            R[i, j] = R[i, j-1] + (R[i, j-1] - R[i-1, j-1]) / (4**j - 1)
            return R, R[max_level-1, max_level-1]
\end{lstlisting}
Tabel Romberg yang dihasilkan berbentuk segitiga, dimana elemen diagonal R[i,i] memberikan aproksimasi terbaik. Nilai di pojok kanan bawah tabel merupakan hasil integral paling akurat yang diperoleh dari metode ini.

\subsection*{Soal 1: $\int_{0}^{\frac{\pi}{2}} \cos(x)  dx$}

Integral fungsi $\cos(x)$ pada interval $[0, \frac{\pi}{2}]$ memiliki nilai eksak $1.00000000000000$.  
Berikut hasil aproksimasi dengan metode \textit{Romberg Integration}:

\[
\text{Tabel Romberg:} \quad
\begin{bmatrix}
0.78539816 & & \\
0.94805945 & 1.00227988 & \\
0.98711580 & 1.00013458 & 0.99999157
\end{bmatrix}
\]

\begin{align*}
\text{Hasil} &= 0.99999157 \\
\text{Error} &= |1.00000000000000 - 0.99999157| = 8.43 \times 10^{-6}
\end{align*}

Metode ini menunjukkan konvergensi cepat melalui penyempurnaan nilai pada setiap iterasi tabel Romberg.  
Nilai pada kolom terakhir mendekati hasil eksak dengan sangat baik, menandakan bahwa estimasi integral semakin akurat pada tingkat iterasi yang lebih tinggi.

\subsection*{Soal 2: $\int_{0}^{1} x^2  dx$}

Integral fungsi $x^2$ pada interval $[0, 1]$ memiliki nilai eksak $0.333333333333333$.  
Berikut hasil aproksimasi dengan metode \textit{Romberg Integration}:

\[
\text{Tabel Romberg:} \quad
\begin{bmatrix}
0.50000000 & & \\
0.37500000 & 0.33333333 & \\
0.34375000 & 0.33333333 & 0.33333333
\end{bmatrix}
\]

\begin{align*}
\text{Hasil} &= 0.33333333 \\
\text{Error} &= 0
\end{align*}

Metode \textit{Romberg Integration} memberikan hasil eksak untuk fungsi polinomial sederhana seperti $x^2$.  
Hal ini terjadi karena proses \textit{Richardson extrapolation} mampu menghilangkan seluruh komponen error pada pendekatan aturan trapezoidal, sehingga hasil konvergen tepat pada nilai integral sebenarnya.


\subsection*{2.5. Perhitungan Metode Adaptive Integration}

\textbf{Soal 1: } Hitung $\int_{0}^{\pi/2} \cos(x) \, dx$ menggunakan Adaptive Simpson

\textbf{Penjelasan Metode Simpson:}

Simpson's Rule adalah metode integrasi numerik yang mengaproksimasi fungsi dengan polinomial kuadrat (parabola). Untuk interval $[a, b]$ dengan titik tengah $c = \frac{a+b}{2}$, rumus Simpson adalah:
\[
S = \frac{h}{6}[f(a) + 4f(c) + f(b)]
\]
di mana $h = b - a$ adalah lebar interval. Rumus ini memberikan hasil eksak untuk polinomial berderajat $\leq 3$, sehingga sangat akurat untuk fungsi yang smooth seperti $\cos(x)$.

\textbf{Konsep Adaptive (Adaptif):}

Metode adaptive berarti algoritma secara otomatis membagi interval menjadi subinterval yang lebih kecil jika diperlukan. Kriterianya: jika $|S_2 - S| > 15 \times \text{tol}$, maka interval dibagi lagi, di mana $S$ adalah hasil Simpson untuk keseluruhan interval dan $S_2$ adalah hasil dari dua subinterval.

\vspace{0.3cm}

\textbf{Implementasi Python:}

\begin{lstlisting}[basicstyle=\ttfamily\footnotesize]
a1 = 0
b1 = np.pi / 2
tol = 1e-10
max_depth = 50
\end{lstlisting}

Inisialisasi parameter integral. Pada kasus ini $a = 0$ adalah batas bawah, $b = \frac{\pi}{2} \approx 1.5708$ adalah batas atas, $\text{tol} = 10^{-10}$ adalah toleransi error yang sangat kecil, dan $\text{max\_depth} = 50$ adalah kedalaman rekursi maksimal untuk mencegah infinite loop.

\begin{lstlisting}[basicstyle=\ttfamily\footnotesize]
c = (a + b) / 2
fa = f(a)  # f(0) = cos(0) = 1.0
fb = f(b)  # f(pi/2) = cos(pi/2) = 0.0
fc = f(c)  # f(pi/4) = cos(pi/4) = 0.707106...
\end{lstlisting}

Hitung titik tengah dan nilai fungsi pada tiga titik penting. Pada kasus ini: $c = \frac{0 + \pi/2}{2} = \frac{\pi}{4} \approx 0.7854$. Nilai fungsi: $f(0) = \cos(0) = 1.0$, $f(\pi/2) = \cos(\pi/2) = 0.0$, dan $f(\pi/4) = \cos(\pi/4) = \frac{\sqrt{2}}{2} \approx 0.7071$.

\begin{lstlisting}[basicstyle=\ttfamily\footnotesize]
def simpson_rule(f, a, b):
    c = (a + b) / 2
    h = b - a
    return (h / 6) * (f(a) + 4 * f(c) + f(b))

S = simpson_rule(f, a, b)
\end{lstlisting}

Fungsi Simpson's Rule untuk interval $[a, b]$. Pada kasus ini: $h = \frac{\pi}{2} - 0 = \frac{\pi}{2} \approx 1.5708$, sehingga $S = \frac{1.5708}{6}[1.0 + 4(0.7071) + 0.0] = 0.2618 \times 3.8284 \approx 1.0023$. Ini adalah aproksimasi awal dengan error sekitar 0.0023 dari nilai eksak 1.0.

\begin{lstlisting}[basicstyle=\ttfamily\footnotesize]
def adaptive_aux(f, a, b, tol, S, fa, fb, fc, depth):
    c = (a + b) / 2
    d = (a + c) / 2  # titik tengah interval kiri
    e = (c + b) / 2  # titik tengah interval kanan
    
    fd = f(d)
    fe = f(e)
\end{lstlisting}

Fungsi rekursif adaptive dimulai dengan menghitung 2 titik tambahan untuk membagi interval menjadi dua bagian. Pada iterasi pertama (depth=50): $d = \frac{0 + \pi/4}{2} = \frac{\pi}{8} \approx 0.3927$ dan $e = \frac{\pi/4 + \pi/2}{2} = \frac{3\pi}{8} \approx 1.1781$. Nilai fungsi: $f(d) = \cos(\pi/8) \approx 0.9239$ dan $f(e) = \cos(3\pi/8) \approx 0.3827$.

\begin{lstlisting}[basicstyle=\ttfamily\footnotesize]
    Sleft = (c - a) / 6 * (fa + 4 * fd + fc)
    Sright = (b - c) / 6 * (fc + 4 * fe + fb)
    S2 = Sleft + Sright
\end{lstlisting}

Hitung Simpson's Rule untuk kedua subinterval. Interval kiri $[0, \pi/4]$: $S_{\text{left}} = \frac{\pi/4}{6}[1.0 + 4(0.9239) + 0.7071] \approx 0.5236$. Interval kanan $[\pi/4, \pi/2]$: $S_{\text{right}} = \frac{\pi/4}{6}[0.7071 + 4(0.3827) + 0.0] \approx 0.4767$. Total: $S_2 = 0.5236 + 0.4767 = 1.0003$.

\begin{lstlisting}[basicstyle=\ttfamily\footnotesize]
    if depth <= 0 or abs(S2 - S) <= 15 * tol:
        return S2 + (S2 - S) / 15
\end{lstlisting}

Cek kriteria konvergensi. Pada iterasi pertama: $|S_2 - S| = |1.0003 - 1.0023| = 0.0020$ dan $15 \times \text{tol} = 15 \times 10^{-10} = 1.5 \times 10^{-9}$. Karena $0.0020 > 1.5 \times 10^{-9}$, kondisi tidak terpenuhi, sehingga belum konvergen. Jika sudah konvergen, kembalikan hasil dengan koreksi Richardson: $S_2 + \frac{S_2 - S}{15}$.

\begin{lstlisting}[basicstyle=\ttfamily\footnotesize]
    return (adaptive_aux(f, a, c, tol/2, Sleft, fa, fc, fd, depth-1) +
            adaptive_aux(f, c, b, tol/2, Sright, fc, fb, fe, depth-1))
\end{lstlisting}

Jika belum konvergen, lakukan rekursi pada kedua subinterval. Proses ini terus berlanjut sampai kriteria konvergensi terpenuhi atau kedalaman maksimal tercapai. Setiap kali rekursi: toleransi dibagi 2 ($\text{tol}/2$), kedalaman berkurang 1 ($\text{depth} - 1$), dan interval dipecah menjadi lebih kecil.

\vspace{0.3cm}

\textbf{Hasil Akhir:}

Setelah rekursi selesai, hasilnya adalah $\text{adaptive1} = 1.000000000000000$ (15 digit presisi) dengan error $\approx 10^{-16}$ (machine precision), jauh lebih kecil dari toleransi $10^{-10}$.

\textbf{Keunggulan Metode:} Otomatis menyesuaikan ukuran interval berdasarkan kompleksitas fungsi, menghasilkan akurasi tinggi dengan evaluasi fungsi minimal, dan untuk fungsi smooth seperti $\cos(x)$, konvergensi sangat cepat dengan hasil hampir sempurna (error $\sim 10^{-16}$).

\vspace{0.5cm}

\textbf{Soal 2: } Hitung $\int_{0}^{1} x^2 \, dx$ menggunakan Adaptive Simpson

\textbf{Implementasi Python:}

\begin{lstlisting}[basicstyle=\ttfamily\footnotesize]
a2 = 0
b2 = 1
tol = 1e-10
max_depth = 50
\end{lstlisting}

Inisialisasi parameter integral. Pada kasus ini $a = 0$ adalah batas bawah, $b = 1$ adalah batas atas, $\text{tol} = 10^{-10}$ adalah toleransi error yang sangat kecil, dan $\text{max\_depth} = 50$ adalah kedalaman rekursi maksimal.

\begin{lstlisting}[basicstyle=\ttfamily\footnotesize]
c = (a + b) / 2
fa = f(a)  # f(0) = 0^2 = 0.0
fb = f(b)  # f(1) = 1^2 = 1.0
fc = f(c)  # f(0.5) = 0.5^2 = 0.25
\end{lstlisting}

Hitung titik tengah dan nilai fungsi pada tiga titik penting. Pada kasus ini: $c = \frac{0 + 1}{2} = 0.5$. Nilai fungsi: $f(0) = 0^2 = 0.0$, $f(1) = 1^2 = 1.0$, dan $f(0.5) = (0.5)^2 = 0.25$.

\begin{lstlisting}[basicstyle=\ttfamily\footnotesize]
def simpson_rule(f, a, b):
    c = (a + b) / 2
    h = b - a
    return (h / 6) * (f(a) + 4 * f(c) + f(b))

S = simpson_rule(f, a, b)
\end{lstlisting}

Fungsi Simpson's Rule untuk interval $[a, b]$. Pada kasus ini: $h = 1 - 0 = 1$, sehingga $S = \frac{1}{6}[0.0 + 4(0.25) + 1.0] = \frac{1}{6}[0.0 + 1.0 + 1.0] = \frac{2.0}{6} = 0.333333...$. Ini adalah aproksimasi awal yang sudah sangat akurat karena $f(x) = x^2$ adalah fungsi polinomial kuadrat, dan Simpson's Rule eksak untuk polinomial derajat $\leq 3$.

\begin{lstlisting}[basicstyle=\ttfamily\footnotesize]
def adaptive_aux(f, a, b, tol, S, fa, fb, fc, depth):
    c = (a + b) / 2
    d = (a + c) / 2  # titik tengah interval kiri
    e = (c + b) / 2  # titik tengah interval kanan
    
    fd = f(d)
    fe = f(e)
\end{lstlisting}

Fungsi rekursif adaptive dimulai dengan menghitung 2 titik tambahan untuk membagi interval menjadi dua bagian. Pada iterasi pertama (depth=50): $d = \frac{0 + 0.5}{2} = 0.25$ dan $e = \frac{0.5 + 1}{2} = 0.75$. Nilai fungsi: $f(d) = (0.25)^2 = 0.0625$ dan $f(e) = (0.75)^2 = 0.5625$.

\begin{lstlisting}[basicstyle=\ttfamily\footnotesize]
    Sleft = (c - a) / 6 * (fa + 4 * fd + fc)
    Sright = (b - c) / 6 * (fc + 4 * fe + fb)
    S2 = Sleft + Sright
\end{lstlisting}

Hitung Simpson's Rule untuk kedua subinterval. Interval kiri $[0, 0.5]$: $S_{\text{left}} = \frac{0.5}{6}[0.0 + 4(0.0625) + 0.25] = \frac{0.5}{6}[0.5] = 0.041666...$. Interval kanan $[0.5, 1]$: $S_{\text{right}} = \frac{0.5}{6}[0.25 + 4(0.5625) + 1.0] = \frac{0.5}{6}[3.5] = 0.291666...$. Total: $S_2 = 0.041666... + 0.291666... = 0.333333...$.

\begin{lstlisting}[basicstyle=\ttfamily\footnotesize]
    if depth <= 0 or abs(S2 - S) <= 15 * tol:
        return S2 + (S2 - S) / 15
\end{lstlisting}

Cek kriteria konvergensi. Pada iterasi pertama: $|S_2 - S| = |0.333333... - 0.333333...| \approx 0$ (sangat kecil, mendekati machine precision) dan $15 \times \text{tol} = 15 \times 10^{-10} = 1.5 \times 10^{-9}$. Karena selisihnya sudah sangat kecil (praktis 0), kondisi terpenuhi dan algoritma langsung konvergen pada iterasi pertama. Kembalikan hasil dengan koreksi Richardson: $S_2 + \frac{S_2 - S}{15}$.

\begin{lstlisting}[basicstyle=\ttfamily\footnotesize]
    return (adaptive_aux(f, a, c, tol/2, Sleft, fa, fc, fd, depth-1) +
            adaptive_aux(f, c, b, tol/2, Sright, fc, fb, fe, depth-1))
\end{lstlisting}

Jika belum konvergen, lakukan rekursi pada kedua subinterval. Namun untuk fungsi $f(x) = x^2$, karena Simpson's Rule sudah memberikan hasil eksak untuk polinomial kuadrat, rekursi biasanya langsung terhenti pada iterasi pertama.

\vspace{0.3cm}

\textbf{Hasil Akhir:}

Setelah proses adaptive selesai, hasilnya adalah $\text{adaptive2} = 0.333333333333333$ (15 digit presisi) dengan error $\approx 10^{-16}$ (machine precision). Nilai eksak adalah $\frac{1}{3} = 0.333333...$

\textbf{Catatan Penting:} Untuk fungsi polinomial seperti $x^2$, metode Adaptive Simpson sangat efisien karena Simpson's Rule sudah memberikan hasil yang sangat akurat (bahkan eksak secara teoritis) sejak iterasi awal, sehingga algoritma cepat konvergen tanpa perlu banyak pembagian interval.

% GAUSSIAN QUADRATURE

\subsection*{2.6. Perhitungan Metode Gaussian Quadrature}

\textbf{Fungsi 1:} $f(x) = \cos(x)$ untuk interval $[0, \frac{\pi}{2}$]

\textbf{Fungsi 2:} $f(x) = x^2$ pada interval $[0, 1]$

import \textit{library} numpy

\begin{lstlisting}
import numpy as np
\end{lstlisting}

Definisikan fungsi \texttt{gaussian\_quadrature} yang menerima $4$ input

\begin{itemize}
    \item f: fungsi yang mau diintegralkan, yaitu $f(x) = \cos(x)$
    \item a: batas bawah integral, yaotu 0
    \item b: batas atas integral, yaitu $\frac{\pi}{2}$
    \item n: jumlah titik (kita pake $n = 5$)
\end{itemize}

\begin{lstlisting}
def gaussian_quadrature(f, a, b, n=5):
\end{lstlisting}

kami menggunakan pendekatan selektif dalam menentukan nodes dan weights untuk Gaussian Quadrature di mana ketika n = 5, nilai-nilai nodes dan weights yang telah ditentukan secara matematis dengan presisi tinggi dimasukkan secara eksplisit ke dalam array untuk mengoptimalkan performa komputasi, sementara untuk nilai n lainnya, kami manfaatkan fungsi np.polynomial.legendre.leggauss(n) dari NumPy yang secara otomatis menghasilkan nodes dan weights yang sesuai.

\begin{lstlisting}
        if n == 5:
        # 5-point Gauss-Legendre nodes dan weights
        nodes = np.array([
            -0.9061798459386640,
            -0.5384693101056831,
            0.0,
            0.5384693101056831,
            0.9061798459386640
        ])
        
        weights = np.array([
            0.2369268850561891,
            0.4786286704993665,
            0.5688888888888889,
            0.4786286704993665,
            0.2369268850561891
        ])
        else:
            # Untuk n lain, gunakan numpy (opsional)
            nodes, weights = np.polynomial.legendre.leggauss(n)
\end{lstlisting}

Bagian ini melakukan proses inti dari integrasi numerik dengan \textit{Gaussian Quadrature}, di mana:

\begin{itemize}
    \item Setiap node yang awalnya berada dalam interval standar $[-1, 1]$ ditransformasikan ke dalam interval target $[a, b]$ menggunakan rumus mapping linear:
    \[
    x = 0.5 \times ((b - a) \times \text{nodes}[i] + (a + b))
    \]
    
    \item Fungsi $f(x)$ dievaluasi pada setiap titik transformasi tersebut dan dikalikan dengan \textit{weight} yang bersesuaian
    
    \item Hasil evaluasi diakumulasi dalam variabel \texttt{result}
    
    \item Hasil akumulasi tersebut diskalakan dengan faktor:
    \[
    0.5 \times (b - a)
    \]
    yang merepresentasikan setengah dari lebar interval integrasi
    
    \item Hasil akhir dikembalikan sebagai output fungsi berupa aproksimasi integral numerik
\end{itemize}

\begin{lstlisting}
    result = 0
    for i in range(len(nodes)):
        x = 0.5 * ((b - a) * nodes[i] + (a + b))
        result += weights[i] * f(x)
    
    result *= 0.5 * (b - a)
    return result
\end{lstlisting}

\subsection*{Soal 1: $\int_{0}^{\frac{\pi}{2}} \cos(x)  dx$} 

Integral fungsi $\cos(x)$ pada interval $[0, \frac{\pi}{2}]$ memiliki nilai eksak $1.00000000000000$. Berikut hasil aproksimasi dengan metode \textit{Gaussian Quadrature}:
\begin{align*}
\text{Hasil} &= 1.000000000039565 \\
\text{Error} &= 3.956592 \times 10^{-11}
\end{align*}
Metode memberikan aproksimasi sangat akurat dengan error yang sangat kecil.

\subsection*{Soal 2: $\int_{0}^{1} x^2  dx$}

Integral fungsi $x^2$ pada interval $[0, 1]$ memiliki nilai eksak $0.333333333333333$. Berikut hasil aproksimasi dengan metode \textit{Gaussian Quadrature}:
\begin{align*}
\text{Hasil} &= 0.333333333333333 \\
\text{Error} &= 0.000000 \times 10^{0} = 0
\end{align*}
Metode memberikan hasil eksak untuk integral fungsi ini.

[Isi langkah-langkah perhitungan menggunakan metode Gaussian Quadrature]

%------------------------------------------------%
% BAGIAN 3: HASIL DAN PERBANDINGAN ERROR
%------------------------------------------------%
\section*{BAGIAN 3: Hasil dan Perbandingan Error}

\subsection*{3.1. Hasil Perhitungan}

Adapun hasil perhitungan komputasi menggunakan metode Trapezoidal, Richardson Extrapolation, Romberg Integration, Adaptive Simpson, dan Gaussian Quadrature disajikan pada tabel di bawah ini. Tabel berikut menunjukkan hasil perhitungan integral numerik menggunakan berbagai metode untuk dua fungsi uji, yaitu \( f(x) = \cos(x) \) dan \( f(x) = x^2 \).

\begin{table}[H]
\centering
\caption{Perbandingan hasil integrasi untuk $f(x) = \cos(x)$ pada interval $[0, \frac{\pi}{2}]$}
\begin{tabularx}{0.95\textwidth}{|l|>{\centering\arraybackslash}X|>{\centering\arraybackslash}X|}
\hline
\textbf{Metode} & \textbf{Hasil} & \textbf{Error} \\
\hline
Trapezoidal (n=4) & 0.98712 & $1.29\times10^{-2}$ \\
Trapezoidal (n=8) & 0.99679 & $3.21\times10^{-3}$ \\
Richardson Extrapolation & 1.00001 & $8.30\times10^{-6}$ \\
Romberg Integration (Level = 3) & 0.99999 & $8.43\times10^{-6}$ \\
Adaptive Integration (depth=50) & 1.00000 & $1.11\times10^{-15}$ \\
Gaussian Quadrature (p=5) & 1.00000 & $3.96\times10^{-11}$ \\
\hline
\end{tabularx}
\end{table}

Dari tabel di atas terlihat bahwa metode Trapezoidal memiliki error terbesar, namun semakin kecil ketika jumlah pembagi (\(n\)) meningkat. Metode lainnya yakni Richardson extrapolation, Romberg integration, Adaptive Integration dan Gaussian Quadrature memberikan hasil dengan error sangat kecil dan memiliki nilai yang mendekati nilai eksaknya.

\begin{table}[H]
\centering
\caption{Perbandingan hasil integrasi untuk $f(x) = x^2$ pada interval $[0, 1]$}
\begin{tabularx}{0.95\textwidth}{|l|>{\centering\arraybackslash}X|>{\centering\arraybackslash}X|}
\hline
\textbf{Metode} & \textbf{Hasil} & \textbf{Error} \\
\hline
Trapezoidal (n=4) & 0.34375 & $1.04\times10^{-2}$ \\
Trapezoidal (n=8) & 0.33594 & $2.60\times10^{-3}$ \\
Richardson Extrapolation & 0.33333 & $0.00$ \\
Romberg Integration (Level = 3) & 0.33333 & $0.00$ \\
Adaptive Integration (depth=50) & 0.33333 & $0.00$ \\
Gaussian Quadrature (p=5) & 0.33333 & $0.00$ \\
\hline
\end{tabularx}
\end{table}

Pada fungsi kuadrat, terlihat bahwa semua metode selain Trapezoidal menghasilkan hasil yang sangat dekat dengan nilai error yang mendekati 0. Walaupun begitu, Akurasi metode Trapezoidal meningkat dengan memperbesar jumlah titik pembagi (\(n\)) seperti yang terlihat pada tabel diatas.

\subsection*{3.2. Perbandingan Error}

Dari hasil perhitungan pada kedua fungsi diatas, dapat dilihat bahwa besarnya error sangat bergantung pada metode dan parameter seperti jumlah pembagian interval (\(n\)).

\begin{enumerate}
    \item \textbf{Metode Trapezoidal Rule} \\
    Pada metode trapezoidal, Error akan menurun ketika jumlah subinterval \(n\) diperbanyak. Hal ini dapat diamati pada Tabel 1 dan Tabel 2 bahwa ketika jumlah n naik maka nilai errornya menurun. Namun jika kita bandingkan dengan metode lainnya, metode trapezoidal ini memiliki error yang paling besar.
    
    \item \textbf{Richardson Extrapolation} \\
       Jika diamati pada kedua tabel diatas, Richardson Extrapolation bisa untuk menurunkan error dengan cukup signifikan baik pada kasus $f(x) = \cos(x)$ ataupun $f(x) = x^2$. Ini menunjukkan bahwa metode Richardson dapat memberikan hasil aproksimasi yang lebih dekat dan error yang lebih kecil.

    \item \textbf{ Romberg Integration} \\
    Metode Romberg menghasilkan nilai aproksimasi yang sangat mendekati nilai eksak, terutama pada fungsi sederhana seperti \( f(x) = x^2 \), di mana hasilnya hampir identik dengan nilai sebenarnya. Namun, pada Tabel 1 terlihat bahwa metode Richardson Extrapolation memberikan hasil yang sedikit lebih akurat. Meskipun demikian, dengan meningkatkan tingkat \textit{Level} pada metode Romberg, akurasi hasil integrasi dapat ditingkatkan lebih jauh sehingga mendekati nilai eksak secara signifikan.
    
        \item \textbf{Adaptive Integration} \\
    Berdasarkan hasil pada Tabel 1 dan Tabel 2, metode Adaptive Integration menunjukkan tingkat akurasi yang sangat tinggi, dengan error yang hampir tidak terlihat. Pada fungsi \( f(x) = \cos(x) \), error-nya hanya sekitar \(1.11\times10^{-15}\), sedangkan pada fungsi \( f(x) = x^2 \) nilainya sangat mendekati nol. 
    Hal ini terjadi karena metode ini bekerja secara adaptif, yaitu membagi interval integrasi menjadi lebih kecil di bagian fungsi yang berubah cepat, dan lebih besar di bagian yang relatif datar. 
    Dengan cara ini, perhitungan menjadi lebih efisien sekaligus sangat akurat. 
    Dari hasil yang diperoleh, dapat dikatakan bahwa metode Adaptive Integration mampu memberikan hasil yang sangat presisi tanpa memerlukan banyak titik pembagi seperti pada metode Trapezoidal.

    \item \textbf{Gaussian Quadrature} \\
    Jika dilihat dari hasil pada kedua tabel, metode Gaussian Quadrature juga memberikan hasil yang sangat akurat. Untuk fungsi \( f(x) = \cos(x) \), error-nya hanya sekitar \(3.96\times10^{-11}\), sedangkan untuk \( f(x) = x^2 \) nilainya tepat sama dengan hasil eksak (error nol). 
    Hal ini karena Gaussian Quadrature dirancang untuk dapat menghitung integral polinomial hingga orde \(2n - 1\) dengan hasil yang benar-benar tepat. 
    Maka tidak heran jika pada fungsi sederhana seperti \(x^2\), hasilnya sempurna. 
    Meskipun error-nya sedikit lebih besar dibandingkan metode Adaptive Integration pada fungsi trigonometri, secara keseluruhan metode ini tetap sangat efisien dan akurat, terutama untuk fungsi yang halus dan terdefinisi dengan baik.

    
\end{enumerate}

Berdasarkan hasil perhitungan komputasi yang diperoleh dapat diamati metode dengan orde tinggi seperti Romberg, Adaptive Integration, dan Gaussian Quadrature menunjukkan error yang jauh lebih kecil dibandingkan metode orde rendah seperti Trapezoidal. 


\subsection*{3.3. Kesimpulan}

Berdasarkan hasil dan analisis perbandingan berbagai metode integrasi numerik yang telah dilakukan, dapat disimpulkan beberapa hal sebagai berikut:

\begin{enumerate}
    \item Besarnya error sangat bergantung pada orde, parameter, dan karakteristik metode yang digunakan. Metode dengan orde rendah seperti \textit{Trapezoidal Rule} memiliki tingkat error yang lebih besar, namun akurasinya dapat ditingkatkan dengan menambah jumlah subinterval (\(n\)).
    
    \item Metode \textit{Richardson Extrapolation} dan \textit{Romberg Integration} mampu meningkatkan akurasi hasil integrasi secara signifikan dibandingkan metode dasar seperti Trapezoidal. Keduanya menggunakan prinsip kombinasi hasil perhitungan sebelumnya untuk memperkirakan nilai yang lebih baik.
    
    \item Metode \textit{Adaptive Integration} dan \textit{Gaussian Quadrature} menunjukkan hasil paling akurat dengan error yang sangat kecil hingga mendekati nol. Hal ini karena keduanya memiliki orde konvergensi tinggi dan secara adaptif menyesuaikan titik evaluasi sesuai karakteristik fungsi.
    
    \item Pada fungsi sederhana seperti \( f(x) = x^2 \), hampir semua metode kecuali Trapezoidal memberikan hasil identik dengan nilai eksak. Namun, pada fungsi non-polynomial seperti \( f(x) = \cos(x) \), hanya metode orde tinggi yang mampu menghasilkan error sangat kecil.
    
    \item Secara keseluruhan, \textit{Adaptive Integration} dan \textit{Gaussian Quadrature} merupakan metode yang paling efisien dan akurat, sementara metode Trapezoidal lebih cocok digunakan untuk perhitungan sederhana atau sebagai dasar pengembangan metode orde lebih tinggi.
\end{enumerate}

%------------------------------------------------%
% AKHIR DOKUMEN
%------------------------------------------------%
\end{document}